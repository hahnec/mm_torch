import torch

def mm_filter(M, criterion = 1e-4):

    chs = M.shape[-1]
    shape = M.shape[:-1] if chs == 16 else M.shape[:-2]
    M = M.reshape(*shape, 4, 4) if chs == 16 else M

    # Complex-valued covariance matrix
    N = 0.25 * torch.stack([
        M[..., 0, 0] + M[..., 1, 1] + M[..., 0, 1] + M[..., 1, 0],
        M[..., 0, 2] + M[..., 1, 2] + 1j * (M[..., 0, 3] + M[..., 1, 3]),
        M[..., 2, 0] + M[..., 2, 1] - 1j * (M[..., 3, 0] + M[..., 3, 1]),
        M[..., 2, 2] + M[..., 3, 3] + 1j * (M[..., 2, 3] - M[..., 3, 2]),
        M[..., 0, 2] + M[..., 1, 2] - 1j * (M[..., 0, 3] + M[..., 1, 3]),
        M[..., 0, 0] - M[..., 1, 1] - M[..., 0, 1] + M[..., 1, 0],
        M[..., 2, 2] - M[..., 3, 3] - 1j * (M[..., 2, 3] + M[..., 3, 2]),
        M[..., 2, 0] - M[..., 2, 1] - 1j * (M[..., 3, 0] - M[..., 3, 1]),
        M[..., 2, 0] + M[..., 2, 1] + 1j * (M[..., 3, 0] + M[..., 3, 1]),
        M[..., 2, 2] - M[..., 3, 3] + 1j * (M[..., 2, 3] + M[..., 3, 2]),
        M[..., 0, 0] - M[..., 1, 1] + M[..., 0, 1] - M[..., 1, 0],
        M[..., 0, 2] - M[..., 1, 2] + 1j * (M[..., 0, 3] - M[..., 1, 3]),
        M[..., 2, 2] + M[..., 3, 3] - 1j * (M[..., 2, 3] - M[..., 3, 2]),
        M[..., 2, 0] - M[..., 2, 1] + 1j * (M[..., 3, 0] - M[..., 3, 1]),
        M[..., 0, 2] - M[..., 1, 2] - 1j * (M[..., 0, 3] - M[..., 1, 3]),
        M[..., 0, 0] + M[..., 1, 1] - M[..., 0, 1] - M[..., 1, 0]
    ], dim=-1).reshape(*shape, 4, 4)

    # Eigen decomposition
    #D, P = torch.linalg.eig(N)
    #D = torch.sort(D.real, dim=-1)[0] # matlab style
    D, P = torch.linalg.eigh(N)

    # set negative eigenvalues to zero and 
    invalid_mask = torch.any(D.real < -1*criterion, dim=-1)#[..., None, None].repeat(1,1,4,4)
    eigenvalues = torch.diag_embed(D).to(P.dtype)
    eigenvalues[invalid_mask, ...] = 1e-5
    newN = torch.matmul(torch.matmul(P, eigenvalues), torch.inverse(P))
    #newN = P @ eigenvalues @ P.transpose(-2, -1).conj()
    
    A = torch.tensor([
        [1, 0, 0, 1],
        [1, 0, 0, -1],
        [0, 1, 1, 0],
        [0, 1j, -1j, 0]
    ], dtype=N.dtype, device=M.device).unsqueeze(0).unsqueeze(0)
    
    F = torch.stack([
        newN[..., 0,0], newN[..., 0,1], newN[..., 1,0], newN[..., 1,1],
        newN[..., 0,2], newN[..., 0,3], newN[..., 1,2], newN[..., 1,3],
        newN[..., 2,0], newN[..., 2,1], newN[..., 3,0], newN[..., 3,1],
        newN[..., 2,2], newN[..., 2,3], newN[..., 3,2], newN[..., 3,3],
    ], dim=-1).reshape(*shape, 4, 4)
    
    M_filtered = torch.matmul(torch.matmul(A, F), torch.inverse(A))
    M_filtered = M_filtered / M_filtered[..., 0, 0][..., None, None].real
    M_filtered = M_filtered.real
        
    M[invalid_mask, ...] = M_filtered[invalid_mask, ...]

    return M.reshape(*shape, 16) if chs == 16 else M, invalid_mask

def EIG(M):

    chs = M.shape[-1]
    shape = M.shape[:-1] if chs == 16 else M.shape[:-2]
    M = M.reshape(*shape, 4, 4) if chs == 16 else M

    # Complex-valued covariance matrix
    N = 0.25 * torch.stack([
        M[..., 0, 0] + M[..., 1, 1] + M[..., 0, 1] + M[..., 1, 0],
        M[..., 0, 2] + M[..., 1, 2] + 1j * (M[..., 0, 3] + M[..., 1, 3]),
        M[..., 2, 0] + M[..., 2, 1] - 1j * (M[..., 3, 0] + M[..., 3, 1]),
        M[..., 2, 2] + M[..., 3, 3] + 1j * (M[..., 2, 3] - M[..., 3, 2]),
        M[..., 0, 2] + M[..., 1, 2] - 1j * (M[..., 0, 3] + M[..., 1, 3]),
        M[..., 0, 0] - M[..., 1, 1] - M[..., 0, 1] + M[..., 1, 0],
        M[..., 2, 2] - M[..., 3, 3] - 1j * (M[..., 2, 3] + M[..., 3, 2]),
        M[..., 2, 0] - M[..., 2, 1] - 1j * (M[..., 3, 0] - M[..., 3, 1]),
        M[..., 2, 0] + M[..., 2, 1] + 1j * (M[..., 3, 0] + M[..., 3, 1]),
        M[..., 2, 2] - M[..., 3, 3] + 1j * (M[..., 2, 3] + M[..., 3, 2]),
        M[..., 0, 0] - M[..., 1, 1] + M[..., 0, 1] - M[..., 1, 0],
        M[..., 0, 2] - M[..., 1, 2] + 1j * (M[..., 0, 3] - M[..., 1, 3]),
        M[..., 2, 2] + M[..., 3, 3] - 1j * (M[..., 2, 3] - M[..., 3, 2]),
        M[..., 2, 0] - M[..., 2, 1] + 1j * (M[..., 3, 0] - M[..., 3, 1]),
        M[..., 0, 2] - M[..., 1, 2] - 1j * (M[..., 0, 3] - M[..., 1, 3]),
        M[..., 0, 0] + M[..., 1, 1] - M[..., 0, 1] - M[..., 1, 0]
    ], dim=-1).reshape(*shape, 4, 4)

    # Eigenvalue extraction
    D = torch.linalg.eigvals(N)

    # all per-pixel eigenvalues have to be positive
    mask = torch.all(D.real > 0, dim=-1)

    return mask

def charpoly(M):

    chs = M.shape[-1]
    shape = M.shape[:-1] if chs == 16 else M.shape[:-2]
    M = M.reshape(*shape, 4, 4) if chs == 16 else M

    C1 = M[..., 0, 0]

    C2 = (3 * M[..., 0, 0]**2 - M[..., 0, 1]**2 - M[..., 0, 2]**2 - M[..., 0, 3]**2 - 
          M[..., 1, 0]**2 - M[..., 1, 1]**2 - M[..., 1, 2]**2 - M[..., 1, 3]**2 - 
          M[..., 2, 0]**2 - M[..., 2, 1]**2 - M[..., 2, 2]**2 - M[..., 2, 3]**2 - 
          M[..., 3, 0]**2 - M[..., 3, 1]**2 - M[..., 3, 2]**2 - M[..., 3, 3]**2)

    C3 = (4 * M[..., 0, 0]**3 + 
          (-4 * M[..., 0, 1]**2 - 4 * M[..., 0, 2]**2 - 4 * M[..., 0, 3]**2 - 
           -4 * M[..., 1, 0]**2 - 4 * M[..., 1, 1]**2 - 4 * M[..., 1, 2]**2 - 4 * M[..., 1, 3]**2 - 
           -4 * M[..., 2, 0]**2 - 4 * M[..., 2, 1]**2 - 4 * M[..., 2, 2]**2 - 4 * M[..., 2, 3]**2 - 
           -4 * M[..., 3, 0]**2 - 4 * M[..., 3, 1]**2 - 4 * M[..., 3, 2]**2 - 4 * M[..., 3, 3]**2) * M[..., 0, 0] + 
          (8 * M[..., 1, 0] * M[..., 1, 1] + 8 * M[..., 2, 0] * M[..., 2, 1] + 8 * M[..., 3, 0] * M[..., 3, 1]) * M[..., 0, 1] + 
          (8 * M[..., 1, 0] * M[..., 1, 2] + 8 * M[..., 2, 0] * M[..., 2, 2] + 8 * M[..., 3, 0] * M[..., 3, 2]) * M[..., 0, 2] + 
          (8 * M[..., 1, 0] * M[..., 1, 3] + 8 * M[..., 2, 0] * M[..., 2, 3] + 8 * M[..., 3, 0] * M[..., 3, 3]) * M[..., 0, 3] + 
          (8 * M[..., 2, 2] * M[..., 3, 3] - 8 * M[..., 2, 3] * M[..., 3, 2]) * M[..., 1, 1] + 
          (-8 * M[..., 2, 1] * M[..., 3, 3] + 8 * M[..., 2, 3] * M[..., 3, 1]) * M[..., 1, 2] + 
          8 * M[..., 1, 3] * (M[..., 2, 1] * M[..., 3, 2] - M[..., 2, 2] * M[..., 3, 1]))

    C4 = (M[..., 0, 0]**4 + M[..., 0, 1]**4 + M[..., 0, 2]**4 + M[..., 1, 0]**4 + 
          M[..., 1, 1]**4 + M[..., 1, 2]**4 + M[..., 2, 0]**4 + M[..., 2, 1]**4 + 
          M[..., 2, 2]**4 + M[..., 0, 3]**4 + M[..., 1, 3]**4 + M[..., 2, 3]**4 + 
          8 * M[..., 2, 2] * M[..., 2, 3] * M[..., 3, 2] * M[..., 3, 3] - 
          8 * M[..., 3, 0] * (M[..., 2, 1] * M[..., 3, 1] + M[..., 2, 2] * M[..., 3, 2] + M[..., 2, 3] * M[..., 3, 3]) * M[..., 2, 0] + 
          8 * M[..., 3, 1] * (M[..., 2, 2] * M[..., 3, 2] + M[..., 2, 3] * M[..., 3, 3]) * M[..., 2, 1] + 
          8 * M[..., 1, 3] * (M[..., 2, 2] * M[..., 2, 3] + M[..., 3, 2] * M[..., 3, 3]) * M[..., 1, 2] + 
          (M[..., 3, 0]**2 - M[..., 3, 1]**2 - M[..., 3, 2]**2 - M[..., 3, 3]**2)**2 + 
          (2 * M[..., 3, 0]**2 - 2 * M[..., 3, 1]**2 - 2 * M[..., 3, 2]**2 + 2 * M[..., 3, 3]**2) * M[..., 2, 3]**2 + 
          (2 * M[..., 2, 3]**2 + 2 * M[..., 3, 0]**2 - 2 * M[..., 3, 1]**2 + 2 * M[..., 3, 2]**2 - 2 * M[..., 3, 3]**2) * M[..., 2, 2]**2 + 
          (2 * M[..., 2, 2]**2 + 2 * M[..., 2, 3]**2 + 2 * M[..., 3, 0]**2 + 2 * M[..., 3, 1]**2 - 2 * M[..., 3, 2]**2 - 2 * M[..., 3, 3]**2) * M[..., 2, 1]**2 + 
          (-2 * M[..., 2, 1]**2 - 2 * M[..., 2, 2]**2 - 2 * M[..., 2, 3]**2 + 2 * M[..., 3, 0]**2 + 2 * M[..., 3, 1]**2 + 2 * M[..., 3, 2]**2 + 2 * M[..., 3, 3]**2) * M[..., 2, 0]**2 + 
          (2 * M[..., 2, 0]**2 - 2 * M[..., 2, 1]**2 - 2 * M[..., 2, 2]**2 + 2 * M[..., 2, 3]**2 + 2 * M[..., 3, 0]**2 - 2 * M[..., 3, 1]**2 - 2 * M[..., 3, 2]**2 + 2 * M[..., 3, 3]**2) * M[..., 1, 3]**2 + 
          (2 * M[..., 1, 3]**2 + 2 * M[..., 2, 0]**2 - 2 * M[..., 2, 1]**2 + 2 * M[..., 2, 2]**2 - 2 * M[..., 2, 3]**2 + 2 * M[..., 3, 0]**2 - 2 * M[..., 3, 1]**2 + 2 * M[..., 3, 2]**2 - 2 * M[..., 3, 3]**2) * M[..., 1, 2]**2 + 
          ((8 * M[..., 2, 1] * M[..., 2, 2] + 8 * M[..., 3, 1] * M[..., 3, 2]) * M[..., 1, 2] + 
          8 * M[..., 1, 3] * (M[..., 2, 1] * M[..., 2, 3] + M[..., 3, 1] * M[..., 3, 3])) * M[..., 1, 1] +
          (2 * M[..., 1, 2]**2 + 2 * M[..., 1, 3]**2 + 2 * M[..., 2, 0]**2 + 2 * M[..., 2, 1]**2 - 2 * M[..., 2, 2]**2 - 2 * M[..., 2, 3]**2 + 2 * M[..., 3, 0]**2 + 2 * M[..., 3, 1]**2 - 2 * M[..., 3, 2]**2 - 2 * M[..., 3, 3]**2) * M[..., 1, 1]**2 + 
          ((-8 * M[..., 2, 0] * M[..., 2, 1] - 8 * M[..., 3, 0] * M[..., 3, 1]) * M[..., 1, 1] + (-8 * M[..., 2, 0] * M[..., 2, 2] - 8 * M[..., 3, 0] * M[..., 3, 2]) * M[..., 1, 2] - 
          8 * M[..., 1, 3] * (M[..., 2, 0] * M[..., 2, 3] + M[..., 3, 0] * M[..., 3, 3])) * M[..., 1, 0] + 
          (-2 * M[..., 1, 1]**2 - 2 * M[..., 1, 2]**2 - 2 * M[..., 1, 3]**2 + 2 * M[..., 2, 0]**2 + 2 * M[..., 2, 1]**2 + 2 * M[..., 2, 2]**2 + 2 * M[..., 2, 3]**2 + 2 * M[..., 3, 0]**2 + 2 * M[..., 3, 1]**2 + 2 * M[..., 3, 2]**2 + 2 * M[..., 3, 3]**2) * M[..., 1, 0]**2 + 
          ((-8 * M[..., 2, 1] * M[..., 3, 2] + 8 * M[..., 2, 2] * M[..., 3, 1]) * M[..., 1, 0] + 
          (8 * M[..., 2, 0] * M[..., 3, 2] - 8 * M[..., 2, 2] * M[..., 3, 0]) * M[..., 1, 1] + 
          8 * M[..., 1, 2] * (-M[..., 2, 0] * M[..., 3, 1] + M[..., 2, 1] * M[..., 3, 0])) * M[..., 0, 3] + 
          (-2 * M[..., 1, 0]**2 + 2 * M[..., 1, 1]**2 + 2 * M[..., 1, 2]**2 - 2 * M[..., 1, 3]**2 - 2 * M[..., 2, 0]**2 + 2 * M[..., 2, 1]**2 + 2 * M[..., 2, 2]**2 - 2 * M[..., 2, 3]**2 - 2 * M[..., 3, 0]**2 + 2 * M[..., 3, 1]**2 + 2 * M[..., 3, 2]**2 - 2 * M[..., 3, 3]**2) * M[..., 0, 3]**2 + 
          ((-8 * M[..., 1, 2] * M[..., 1, 3] - 8 * M[..., 2, 2] * M[..., 2, 3] - 8 * M[..., 3, 2] * M[..., 3, 3]) * M[..., 0, 3] + 
          (8 * M[..., 2, 1] * M[..., 3, 3] - 8 * M[..., 2, 3] * M[..., 3, 1]) * M[..., 1, 0] + 
          (-8 * M[..., 2, 0] * M[..., 3, 3] + 8 * M[..., 2, 3] * M[..., 3, 0]) * M[..., 1, 1] - 
          8 * M[..., 1, 3] * (-M[..., 2, 0] * M[..., 3, 1] + M[..., 2, 1] * M[..., 3, 0])) * M[..., 0, 2] + 
          (2 * M[..., 0, 3]**2 - 2 * M[..., 1, 0]**2 + 2 * M[..., 1, 1]**2 - 2 * M[..., 1, 2]**2 + 2 * M[..., 1, 3]**2 - 2 * M[..., 2, 0]**2 + 2 * M[..., 2, 1]**2 - 2 * M[..., 2, 2]**2 + 2 * M[..., 2, 3]**2 - 2 * M[..., 3, 0]**2 + 2 * M[..., 3, 1]**2 - 2 * M[..., 3, 2]**2 + 2 * M[..., 3, 3]**2) * M[..., 0, 2]**2 + 
          ((-8 * M[..., 1, 1] * M[..., 1, 2] - 8 * M[..., 2, 1] * M[..., 2, 2] - 8 * M[..., 3, 1] * M[..., 3, 2]) * M[..., 0, 2] + 
          (-8 * M[..., 1, 1] * M[..., 1, 3] - 8 * M[..., 2, 1] * M[..., 2, 3] - 8 * M[..., 3, 1] * M[..., 3, 3]) * M[..., 0, 3] + 
          (-8 * M[..., 2, 2] * M[..., 3, 3] + 8 * M[..., 2, 3] * M[..., 3, 2]) * M[..., 1, 0] + 
          (8 * M[..., 2, 0] * M[..., 3, 3] - 8 * M[..., 2, 3] * M[..., 3, 0]) * M[..., 1, 2] + 
          8 * M[..., 1, 3] * (-M[..., 2, 0] * M[..., 3, 2] + M[..., 2, 2] * M[..., 3, 0])) * M[..., 0, 1] + 
          (2 * M[..., 0, 2]**2 + 2 * M[..., 0, 3]**2 - 2 * M[..., 1, 0]**2 - 2 * M[..., 1, 1]**2 + 2 * M[..., 1, 2]**2 + 2 * M[..., 1, 3]**2 - 2 * M[..., 2, 0]**2 - 2 * M[..., 2, 1]**2 + 2 * M[..., 2, 2]**2 + 2 * M[..., 2, 3]**2 - 2 * M[..., 3, 0]**2 - 2 * M[..., 3, 1]**2 + 2 * M[..., 3, 2]**2 + 2 * M[..., 3, 3]**2) * M[..., 0, 1]**2 + 
          ((8 * M[..., 1, 0] * M[..., 1, 1] + 8 * M[..., 2, 0] * M[..., 2, 1] + 8 * M[..., 3, 0] * M[..., 3, 1]) * M[..., 0, 1] + 
          (8 * M[..., 1, 0] * M[..., 1, 2] + 8 * M[..., 2, 0] * M[..., 2, 2] + 8 * M[..., 3, 0] * M[..., 3, 2]) * M[..., 0, 2] + 
          (8 * M[..., 1, 0] * M[..., 1, 3] + 8 * M[..., 2, 0] * M[..., 2, 3] + 8 * M[..., 3, 0] * M[..., 3, 3]) * M[..., 0, 3] + 
          (8 * M[..., 2, 2] * M[..., 3, 3] - 8 * M[..., 2, 3] * M[..., 3, 2]) * M[..., 1, 1] + 
          (-8 * M[..., 2, 1] * M[..., 3, 3] + 8 * M[..., 2, 3] * M[..., 3, 1]) * M[..., 1, 2] + 
          8 * M[..., 1, 3] * (M[..., 2, 1] * M[..., 3, 2] - M[..., 2, 2] * M[..., 3, 1])) * M[..., 0, 0] + 
          (-2 * M[..., 0, 1]**2 - 2 * M[..., 0, 2]**2 - 2 * M[..., 0, 3]**2 - 2 * M[..., 1, 0]**2 - 
          2 * M[..., 1, 1]**2 - 2 * M[..., 1, 2]**2 - 2 * M[..., 1, 3]**2 - 2 * M[..., 2, 0]**2 - 
          2 * M[..., 2, 1]**2 - 2 * M[..., 2, 2]**2 - 2 * M[..., 2, 3]**2 - 2 * M[..., 3, 0]**2 - 
          2 * M[..., 3, 1]**2 - 2 * M[..., 3, 2]**2 - 2 * M[..., 3, 3]**2) * M[..., 0, 0]**2)
    
    return ((C1 >= 0) & (C2 >= 0) & (C3 >= 0) & (C4 >= 0))


if __name__ == '__main__':

    M = torch.rand(10, 4, 4) * -1
    result = charpoly(M)
    print(result)

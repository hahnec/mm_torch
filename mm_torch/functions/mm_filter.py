import torch

def EIG(M):

    chs = M.shape[-1]
    shape = M.shape[:-1] if chs == 16 else M.shape[:-2]
    M = M.reshape(*shape, 4, 4) if chs == 16 else M

    # Complex-valued covariance matrix
    N = 0.25 * torch.stack([
        M[..., 0, 0] + M[..., 1, 1] + M[..., 0, 1] + M[..., 1, 0],
        M[..., 0, 2] + M[..., 1, 2] + 1j * (M[..., 0, 3] + M[..., 1, 3]),
        M[..., 2, 0] + M[..., 2, 1] - 1j * (M[..., 3, 0] + M[..., 3, 1]),
        M[..., 2, 2] + M[..., 3, 3] + 1j * (M[..., 2, 3] - M[..., 3, 2]),
        M[..., 0, 2] + M[..., 1, 2] - 1j * (M[..., 0, 3] + M[..., 1, 3]),
        M[..., 0, 0] - M[..., 1, 1] - M[..., 0, 1] + M[..., 1, 0],
        M[..., 2, 2] - M[..., 3, 3] - 1j * (M[..., 2, 3] + M[..., 3, 2]),
        M[..., 2, 0] - M[..., 2, 1] - 1j * (M[..., 3, 0] - M[..., 3, 1]),
        M[..., 2, 0] + M[..., 2, 1] + 1j * (M[..., 3, 0] + M[..., 3, 1]),
        M[..., 2, 2] - M[..., 3, 3] + 1j * (M[..., 2, 3] + M[..., 3, 2]),
        M[..., 0, 0] - M[..., 1, 1] + M[..., 0, 1] - M[..., 1, 0],
        M[..., 0, 2] - M[..., 1, 2] + 1j * (M[..., 0, 3] - M[..., 1, 3]),
        M[..., 2, 2] + M[..., 3, 3] - 1j * (M[..., 2, 3] - M[..., 3, 2]),
        M[..., 2, 0] - M[..., 2, 1] + 1j * (M[..., 3, 0] - M[..., 3, 1]),
        M[..., 0, 2] - M[..., 1, 2] - 1j * (M[..., 0, 3] - M[..., 1, 3]),
        M[..., 0, 0] + M[..., 1, 1] - M[..., 0, 1] - M[..., 1, 0]
    ], dim=-1).reshape(*shape, 4, 4)

    # Eigenvalue extraction
    D = torch.linalg.eigvals(N)

    # all per-pixel eigenvalues have to be positive
    mask = torch.all(D.real > 0, dim=-1)

    return mask

def mm_filter(M, criterion = 1e-4):

    chs = M.shape[-1]
    shape = M.shape[:-1] if chs == 16 else M.shape[:-2]
    M = M.reshape(*shape, 4, 4) if chs == 16 else M

    # Complex-valued covariance matrix
    N = 0.25 * torch.stack([
        M[..., 0, 0] + M[..., 1, 1] + M[..., 0, 1] + M[..., 1, 0],
        M[..., 0, 2] + M[..., 1, 2] + 1j * (M[..., 0, 3] + M[..., 1, 3]),
        M[..., 2, 0] + M[..., 2, 1] - 1j * (M[..., 3, 0] + M[..., 3, 1]),
        M[..., 2, 2] + M[..., 3, 3] + 1j * (M[..., 2, 3] - M[..., 3, 2]),
        M[..., 0, 2] + M[..., 1, 2] - 1j * (M[..., 0, 3] + M[..., 1, 3]),
        M[..., 0, 0] - M[..., 1, 1] - M[..., 0, 1] + M[..., 1, 0],
        M[..., 2, 2] - M[..., 3, 3] - 1j * (M[..., 2, 3] + M[..., 3, 2]),
        M[..., 2, 0] - M[..., 2, 1] - 1j * (M[..., 3, 0] - M[..., 3, 1]),
        M[..., 2, 0] + M[..., 2, 1] + 1j * (M[..., 3, 0] + M[..., 3, 1]),
        M[..., 2, 2] - M[..., 3, 3] + 1j * (M[..., 2, 3] + M[..., 3, 2]),
        M[..., 0, 0] - M[..., 1, 1] + M[..., 0, 1] - M[..., 1, 0],
        M[..., 0, 2] - M[..., 1, 2] + 1j * (M[..., 0, 3] - M[..., 1, 3]),
        M[..., 2, 2] + M[..., 3, 3] - 1j * (M[..., 2, 3] - M[..., 3, 2]),
        M[..., 2, 0] - M[..., 2, 1] + 1j * (M[..., 3, 0] - M[..., 3, 1]),
        M[..., 0, 2] - M[..., 1, 2] - 1j * (M[..., 0, 3] - M[..., 1, 3]),
        M[..., 0, 0] + M[..., 1, 1] - M[..., 0, 1] - M[..., 1, 0]
    ], dim=-1).reshape(*shape, 4, 4)

    # Eigen decomposition
    #D, P = torch.linalg.eig(N)
    #D = torch.sort(D.real, dim=-1)[0] # matlab style
    D, P = torch.linalg.eigh(N)

    # set negative eigenvalues to zero and 
    invalid_mask = torch.any(D.real < -1*criterion, dim=-1)#[..., None, None].repeat(1,1,4,4)
    eigenvalues = torch.diag_embed(D).to(P.dtype)
    eigenvalues[invalid_mask, ...] = 1e-5
    newN = torch.matmul(torch.matmul(P, eigenvalues), torch.inverse(P))
    #newN = P @ eigenvalues @ P.transpose(-2, -1).conj()
    
    A = torch.tensor([
        [1, 0, 0, 1],
        [1, 0, 0, -1],
        [0, 1, 1, 0],
        [0, 1j, -1j, 0]
    ], dtype=N.dtype, device=M.device).unsqueeze(0).unsqueeze(0)
    
    F = torch.stack([
        newN[..., 0,0], newN[..., 0,1], newN[..., 1,0], newN[..., 1,1],
        newN[..., 0,2], newN[..., 0,3], newN[..., 1,2], newN[..., 1,3],
        newN[..., 2,0], newN[..., 2,1], newN[..., 3,0], newN[..., 3,1],
        newN[..., 2,2], newN[..., 2,3], newN[..., 3,2], newN[..., 3,3],
    ], dim=-1).reshape(*shape, 4, 4)
    
    M_filtered = torch.matmul(torch.matmul(A, F), torch.inverse(A))
    M_filtered = M_filtered / M_filtered[..., 0, 0][..., None, None].real
    M_filtered = M_filtered.real
        
    M[invalid_mask, ...] = M_filtered[invalid_mask, ...]

    return M.reshape(*shape, 16) if chs == 16 else M, invalid_mask

def C1(M):
    return 4 * M[..., 0, 0]

def C2(M):
    return (6 * M[..., 0, 0]**2 - 2 * (M[..., 0, 1]**2 + M[..., 0, 2]**2 + M[..., 0, 3]**2 + 
                                      M[..., 1, 0]**2 + M[..., 1, 1]**2 + M[..., 1, 2]**2 + M[..., 1, 3]**2 + 
                                      M[..., 2, 0]**2 + M[..., 2, 1]**2 + M[..., 2, 2]**2 + M[..., 2, 3]**2 + 
                                      M[..., 3, 0]**2 + M[..., 3, 1]**2 + M[..., 3, 2]**2 + M[..., 3, 3]**2))

def C3(M):
    return (4 * M[..., 0, 0]**3 + (-4 * (M[..., 0, 1]**2 + M[..., 0, 2]**2 + M[..., 0, 3]**2 + 
                                        M[..., 1, 0]**2 + M[..., 1, 1]**2 + M[..., 1, 2]**2 + M[..., 1, 3]**2 + 
                                        M[..., 2, 0]**2 + M[..., 2, 1]**2 + M[..., 2, 2]**2 + M[..., 2, 3]**2 + 
                                        M[..., 3, 0]**2 + M[..., 3, 1]**2 + M[..., 3, 2]**2 + M[..., 3, 3]**2)) * M[..., 0, 0] + 
            8 * (M[..., 1, 0] * M[..., 1, 1] + M[..., 2, 0] * M[..., 2, 1] + M[..., 3, 0] * M[..., 3, 1]) * M[..., 0, 1] + 
            8 * (M[..., 1, 0] * M[..., 1, 2] + M[..., 2, 0] * M[..., 2, 2] + M[..., 3, 0] * M[..., 3, 2]) * M[..., 0, 2] + 
            8 * (M[..., 1, 0] * M[..., 1, 3] + M[..., 2, 0] * M[..., 2, 3] + M[..., 3, 0] * M[..., 3, 3]) * M[..., 0, 3] + 
            8 * (M[..., 2, 2] * M[..., 3, 3] - M[..., 2, 3] * M[..., 3, 2]) * M[..., 1, 1] + 
            (-8 * M[..., 2, 1] * M[..., 3, 3] + 8 * M[..., 2, 3] * M[..., 3, 1]) * M[..., 1, 2] + 
            8 * M[..., 1, 3] * (M[..., 2, 1] * M[..., 3, 2] - M[..., 2, 2] * M[..., 3, 1]))

def C4(M):
    return (M[..., 0, 0]**4 + M[..., 0, 1]**4 + M[..., 0, 2]**4 + M[..., 1, 0]**4 + 
            M[..., 1, 1]**4 + M[..., 1, 2]**4 + M[..., 2, 0]**4 + M[..., 2, 1]**4 + 
            M[..., 2, 2]**4 + M[..., 0, 3]**4 + M[..., 1, 3]**4 + M[..., 2, 3]**4 + 
            8 * M[..., 2, 2] * M[..., 2, 3] * M[..., 3, 2] * M[..., 3, 3] - 
            8 * M[..., 3, 0] * (M[..., 2, 1] * M[..., 3, 1] + M[..., 2, 2] * M[..., 3, 2] + 
                               M[..., 2, 3] * M[..., 3, 3]) * M[..., 2, 0] + 
            8 * M[..., 3, 1] * (M[..., 2, 2] * M[..., 3, 2] + M[..., 2, 3] * M[..., 3, 3]) * M[..., 2, 1] + 
            8 * M[..., 1, 3] * (M[..., 2, 2] * M[..., 2, 3] + M[..., 3, 2] * M[..., 3, 3]) * M[..., 1, 2] + 
            (M[..., 3, 0]**2 - M[..., 3, 1]**2 - M[..., 3, 2]**2 - M[..., 3, 3]**2)**2 + 
            (2 * M[..., 3, 0]**2 - 2 * M[..., 3, 1]**2 - 2 * M[..., 3, 2]**2 + 2 * M[..., 3, 3]**2) * M[..., 2, 3]**2 + 
            (2 * M[..., 2, 3]**2 + 2 * M[..., 3, 0]**2 - 2 * M[..., 3, 1]**2 + 2 * M[..., 3, 2]**2 - 
             2 * M[..., 3, 3]**2) * M[..., 2, 2]**2 + (2 * M[..., 2, 2]**2 + 2 * M[..., 2, 3]**2 + 
                                                     2 * M[..., 3, 0]**2 + 2 * M[..., 3, 1]**2 - 
                                                     2 * M[..., 3, 2]**2 - 2 * M[..., 3, 3]**2) * M[..., 2, 1]**2 + 
            (-2 * M[..., 2, 1]**2 - 2 * M[..., 2, 2]**2 - 2 * M[..., 2, 3]**2 + 
             2 * M[..., 3, 0]**2 + 2 * M[..., 3, 1]**2 + 2 * M[..., 3, 2]**2 + 
             2 * M[..., 3, 3]**2))

def PSD(M):
    shape = M.shape
    if shape[-1] == 16: M = M.view(*shape[:-1], 4, 4)
    return ((C1(M) >= 0) & (C2(M) >= 0) & (C3(M) >= 0) & (C4(M) >= 0))

import torch

# Define the D1 function
def D1(M):
    return M[..., 0, 0] + M[..., 0, 1] + M[..., 1, 0] + M[..., 1, 1]

# Define the D2 function
def D2(M):
    return (
        M[..., 0, 0]**2 + 2 * M[..., 0, 0] * M[..., 1, 0] -
        M[..., 0, 1]**2 - 2 * M[..., 0, 1] * M[..., 1, 1] -
        M[..., 0, 2]**2 - 2 * M[..., 0, 2] * M[..., 1, 2] -
        M[..., 0, 3]**2 - 2 * M[..., 0, 3] * M[..., 1, 3] +
        M[..., 1, 0]**2 - M[..., 1, 1]**2 -
        M[..., 1, 2]**2 - M[..., 1, 3]**2
    )

# Define the D3 function
def D3(M):
    return (
        M[..., 0, 0]**3 + (M[..., 0, 1] + M[..., 1, 0] - M[..., 1, 1]) * M[..., 0, 0]**2 +
        (-M[..., 0, 1]**2 + (2 * M[..., 1, 0] - 2 * M[..., 1, 1]) * M[..., 0, 1] - M[..., 2, 1]**2 - 2 * M[..., 2, 0] * M[..., 2, 1] - M[..., 2, 2]**2 + 2 * M[..., 2, 2] * M[..., 3, 3] - M[..., 2, 3]**2 - 2 * M[..., 2, 3] * M[..., 3, 2] - M[..., 3, 0]**2 - 2 * M[..., 3, 0] * M[..., 3, 1] - M[..., 3, 1]**2 - M[..., 3, 2]**2 - M[..., 3, 3]**2 - M[..., 0, 2]**2 - 2 * M[..., 0, 2] * M[..., 1, 2] - M[..., 0, 3]**2 - 2 * M[..., 0, 3] * M[..., 1, 3] - M[..., 1, 0]**2 - 2 * M[..., 1, 0] * M[..., 1, 1] - M[..., 1, 1]**2 - M[..., 1, 2]**2 - M[..., 1, 3]**2 - M[..., 2, 0]**2) * M[..., 0, 0] -
        M[..., 0, 1]**3 + (M[..., 1, 0] - M[..., 1, 1]) * M[..., 0, 1]**2 +
        (-M[..., 0, 2]**2 - 2 * M[..., 0, 2] * M[..., 1, 2] - M[..., 0, 3]**2 - 2 * M[..., 0, 3] * M[..., 1, 3] + M[..., 1, 0]**2 + 2 * M[..., 1, 0] * M[..., 1, 1] + M[..., 1, 1]**2 - M[..., 1, 2]**2 - M[..., 1, 3]**2 + M[..., 2, 0]**2 + 2 * M[..., 2, 0] * M[..., 2, 1] + M[..., 2, 1]**2 - M[..., 2, 2]**2 + 2 * M[..., 2, 2] * M[..., 3, 3] - M[..., 2, 3]**2 - 2 * M[..., 2, 3] * M[..., 3, 2] + M[..., 3, 0]**2 + 2 * M[..., 3, 0] * M[..., 3, 1] + M[..., 3, 1]**2 - M[..., 3, 2]**2 - M[..., 3, 3]**2) * M[..., 0, 1] -
        M[..., 1, 0]**3 - M[..., 1, 0]**2 * M[..., 1, 1] +
        (M[..., 0, 2]**2 + 2 * M[..., 0, 2] * M[..., 1, 2] + M[..., 0, 3]**2 + 2 * M[..., 0, 3] * M[..., 1, 3] + M[..., 1, 1]**2 + M[..., 1, 2]**2 + M[..., 1, 3]**2 - M[..., 2, 0]**2 - 2 * M[..., 2, 0] * M[..., 2, 1] - M[..., 2, 1]**2 - M[..., 2, 2]**2 + 2 * M[..., 2, 2] * M[..., 3, 3] - M[..., 2, 3]**2 - 2 * M[..., 2, 3] * M[..., 3, 2] - M[..., 3, 0]**2 - 2 * M[..., 3, 0] * M[..., 3, 1] - M[..., 3, 1]**2 - M[..., 3, 2]**2 - M[..., 3, 3]**2) * M[..., 1, 0] +
        M[..., 1, 1]**3 +
        (M[..., 0, 2]**2 + 2 * M[..., 0, 2] * M[..., 1, 2] + M[..., 0, 3]**2 + 2 * M[..., 0, 3] * M[..., 1, 3] + M[..., 1, 2]**2 + M[..., 1, 3]**2 + M[..., 2, 0]**2 + 2 * M[..., 2, 0] * M[..., 2, 1] + M[..., 2, 1]**2 - M[..., 2, 2]**2 + 2 * M[..., 2, 2] * M[..., 3, 3] - M[..., 2, 3]**2 - 2 * M[..., 2, 3] * M[..., 3, 2] + M[..., 3, 0]**2 + 2 * M[..., 3, 0] * M[..., 3, 1] + M[..., 3, 1]**2 - M[..., 3, 2]**2 - M[..., 3, 3]**2) * M[..., 1, 1] +
        ((2 * M[..., 2, 2] - 2 * M[..., 3, 3]) * M[..., 2, 0] + (2 * M[..., 2, 2] - 2 * M[..., 3, 3]) * M[..., 2, 1] + 2 * (M[..., 3, 0] + M[..., 3, 1]) * (M[..., 2, 3] + M[..., 3, 2])) * M[..., 0, 2] +
        ((2 * M[..., 2, 3] + 2 * M[..., 3, 2]) * M[..., 2, 0] + (2 * M[..., 2, 3] + 2 * M[..., 3, 2]) * M[..., 2, 1] - 2 * (M[..., 3, 0] + M[..., 3, 1]) * (M[..., 2, 2] - M[..., 3, 3])) * M[..., 0, 3] +
        ((2 * M[..., 2, 2] - 2 * M[..., 3, 3]) * M[..., 2, 0] + (2 * M[..., 2, 2] - 2 * M[..., 3, 3]) * M[..., 2, 1] + 2 * (M[..., 3, 0] + M[..., 3, 1]) * (M[..., 2, 3] + M[..., 3, 2])) * M[..., 1, 2] +
        2 * M[..., 1, 3] * ((M[..., 2, 3] + M[..., 3, 2]) * M[..., 2, 0] + (M[..., 2, 3] + M[..., 3, 2]) * M[..., 2, 1] - (M[..., 3, 0] + M[..., 3, 1]) * (M[..., 2, 2] - M[..., 3, 3]))
    )

def SC(M):
    shape = M.shape
    if shape[-1] == 16: M = M.view(*shape[:-1], 4, 4)
    return ((D1(M) >= 0) & (D2(M) >= 0) & (D3(M) >= 0))


if __name__ == '__main__':

    M = torch.rand(10, 4, 4) * -1
    result = PSD(M)
    result = SC(M)
    print(result)
